\documentclass[full]{l3doc}
\usepackage[scheme=plain]{ctex}
\usepackage{zhlineskip}
\usepackage{enumitem}
\usepackage{indentfirst}
\usepackage{titling}
\usepackage{geometry}
\usepackage{tabularray}
\usepackage{xcolor}

\IndexPrologue
  {
    \section*{Index}
    \markboth{Index}{Index}
    \addcontentsline{toc}{section}{Index}
    The~italic~numbers~denote~the~pages~where~the~
    corresponding~entry~is~described,~
    numbers~underlined~point~to~the~definition,~
    all~others~indicate~the~places~where~it~is~used.
  }

\newcommand\tikzmark[1]{\tikz \coordinate[overlay, remember picture] (#1);}

\geometry{
  left=4.5cm,
  right=2cm,
  top=2cm,
  bottom=2cm,
}
\hypersetup {
  CJKbookmarks,
  bookmarksopen,
  bookmarksopenlevel=3,
  pdfstartview=FitH,
  pdfinfo = {
   Title = The package 'review' ,
   Subject = A LaTeX package ,
   Author = Li Changkai
 }
}

\DoNotIndex{\begin, \end}
\setlength{\parskip}{\medskipamount}
\DeclareDocumentEnvironment { note } { +b } {
  \par\textbf{\textsf{NOTE:~}}#1\par
} {}

\AtEndDocument{
  \newgeometry{
    left=2cm,
    right=2cm,
    top=2cm,
    bottom=2cm
  }
  \PrintIndex
}

\ExplSyntaxOn
\dim_new:N \l__my_syntax_dim
\box_new:N \g__my_syntax_box
\NewDocumentEnvironment { Syntax } { s }
  {
    \dim_set:Nn \l__my_syntax_dim
      { \textwidth }
    \hbox_gset:Nw \g__my_syntax_box
      \small \ttfamily
      \begin{minipage}[t]{\l__my_syntax_dim}
        \raggedright\obeyspaces\obeylines
  }
  {
      \end{minipage}
    \hbox_gset_end:
    \IfValueF { #1 } { \smallskip }
    \box_use_drop:N \g__my_syntax_box
    \smallskip
  }

\DeclareDocumentEnvironment { Description } { o +b } {
  \hbox_set:Nn \l_tmpa_box { #1 }
  \dim_set:Nn \l_tmpa_dim { \box_wd:N \l_tmpa_box }
  \begin{itemize}[labelwidth=\l_tmpa_dim, align=left]
    #2
  \end{itemize}
} {  }

\keys_define:nn { review/doc } {
  opt .tl_set:N = \l_opt_tl,
  desc .tl_set:N = \l_desc_tl,
  init .tl_set:N = \l_init_tl,
  init .initial:n = init-none,
}

\box_new:N \l__option_box
\NewDocumentEnvironment { option } { m +b } {
  \keys_set:nn { review/doc } { #1 }
  \hbox_set:Nw \l__option_box
    \small \ttfamily
    \begin{minipage}[t]{\textwidth}
      \obeyspaces\obeylines
      \textcolor{red}{
        \l_opt_tl
        \exp_args:Nx\SpecialOptionIndex{\l_opt_tl}
      }
      {~}\l_desc_tl
      \hfill(
      \tl_if_eq:NnTF \l_init_tl { init-none } { no~value }
        { initially~\texttt{\l_init_tl} }
      )
    \end{minipage}
  \hbox_gset_end:
  \box_use_drop:N \l__option_box
  #2
  \medskip
} {  }

\DeclareDocumentCommand \opt { O{} m }
  { \__codedoc_cmd:no {#1} { #2 } }
\ExplSyntaxOff


\begin{document}
\title{
  \pkg{review} 宏包
  \protect\footnote{\url{https://github.com/ZhiyuanLck/review}}
  \rlap{\makebox[4cm][r]{
    \normalsize $\Longrightarrow$ \color{red}
    \protect\hyperlink{en}{English Version}
    \protect\hypertarget{zh}{}
  }}
}
\author{\textit{李昌锴} \texttt{<lichangkai225\@qq.com>}}
\date{2022年1月3日}
\maketitle

{\small
\tableofcontents
}
\newpage

\begin{documentation}

\section{引言}
编写本宏包的动机来源于当前没有一个很好的错题本宏包，可以方便的根据各种条件对错
题进行筛选、排序，然后以自定义的样式展示出来。\pkg{review} 宏包实现了四个核心
功能：数据存储和使用、数据筛选、数据排序、数据展示。

数据只需要存储一次，就可以通过预定义的筛选、排序条件和样式展示部分或全部的数据。
如上所述，本宏包其实实现了一个非常简单的数据库，复习错题的功能只是其中一个应用，
和其他数据库宏包比如 \pkg{datatool} 相比，\pkg{review} 更专注于非图表类型的数
据展示。

宏包基于 \pkg{expl3} 的基础类型构建了6种类型：
\begin{Description}[\texttt{clist}]
  \item[\texttt{date}]
    基于宏包 \pkg{datetime2} 的日期类型，以iso标准存储，支持大小比较，排序（转
    换成字符串）。默认值为 \cs{Today}。
  \item[\texttt{str}]
    字符串类型，支持正则匹配，英文排序。默认值为空。
  \item[\texttt{tl}]
    \meta{token list}类型，支持正则匹配。默认值为空。
  \item[\texttt{int}]
    整数类型，支持大小比较，排序。默认值为0。
  \item[\texttt{fp}]
    浮点数类型，支持大小比较，排序。默认值为0。
  \item[\texttt{clist}]
    逗号分隔的列表类型。默认值为空列表。
\end{Description}

\section{接口文档}
\subsection{\cs{rvNewGroup}}
\begin{function}{\rvNewGroup, \rvNewGroup*}
  \begin{syntax}
    \cs{rvNewGroup} \oarg{base group} \marg{group} \{ \\
    ~~\meta{attr1} = \meta{type spec1}, \\
    ~~\meta{attr2} = \meta{type spec2}, \\
    ~~\ldots{} \\
    \} \\
    \cs{rvNewGroup}* \marg{group} \{ \\
    ~~\meta{attr1} = \meta{type spec1}, \\
    ~~\meta{attr2} = \meta{type spec2}, \\
    ~~\ldots{} \\
    \} \\
  \end{syntax}

\end{function}

  新建一个组来存储数据，不带星号的版本可以指定一个组来继承属性设置，该版本总是
  会舍弃掉之前的定义。

  带星号的版本不会舍弃之前已有的定义，而是将新的选项添加到后面。

  \meta{attr} 为属性名称，\meta{type spec} 负责声明属性类型和属性默认值：

  \noindent\begin{tblr}{
    colspec = {ll},
    column{1} = {font = \ttfamily}
  }
    \meta{attr} = \meta{type} &
    将 \meta{attr} 声明为 \meta{type} 类型 \\
    \meta{attr} = \meta{type}\textbar\meta{default} &
    将 \meta{attr} 声明为 \meta{type} 类型，并且将默认值设置为 \meta{default}。
    \\
  \end{tblr}

  \begin{note}
    每个组都有一个默认的属性 |id| 用来存储数据的索引。
  \end{note}

  下面是定义一个错题组的示例，|question| 和 |answer| 属性用来存储问题和答案，
  |date| 属性存储日期，|info| 属性存储额外信息，|labels| 存储题目标签。
\begin{verbatim}
  \rvNewGroup{ques}{
    question = tl,
    answer = tl,
    date = date,
    info = tl,
    labels = clist
  }
\end{verbatim}

\subsection{\cs{rvNewGroupStyle} 和样式选项}

\begin{function}{\rvNewGroupStyle}
  \begin{syntax}
    \cs{rvNewGroupStyle} \oarg{base styles} \marg{style} \marg{group} \marg{opts}
  \end{syntax}

  为 \meta{group} 定义一个新的样式 \meta{style}，该样式可以基于已有的样式
  \meta{base styles}，比如 |\rvNewGroupStyle[base1, base2]{new-style}{ques}{}|。
\end{function}

\bigskip

\begin{option}{opt=filter, desc={= \meta{filter}}, init=-none-}
  为当前样式设置由 \cs{rvCombineFilters} 所定义的过滤器
\end{option}

\begin{option}{
  opt = sort,
  desc = {= \{ \meta{attr spec1}, \meta{attr spec2}, \ldots{} \}},
}
  为当前样式设置排序规则。支持根据 |str|，|date|，|int|，|fp| 类型的数据进行排
  序，支持多级排序。\meta{attr} 表示增序，\meta{attr}* 表示降序。下面例子中，
  使用 |sort-style| 展示数据时的顺序为先按 |level| 降序，|level| 相同的再按出
  生日期 |birth| 增序，以此类推。
\end{option}

\begin{verbatim}
  \rvNewGroup{sort-example}{
    name = str,
    birth = date,
    level = int,
    weight = fp,
  }
  \rvNewGroupStyle{sort-style}{sort-example}{
    sort = { level*, birth, name, weight }
  }
\end{verbatim}

\begin{option}{
  opt = before-code,
  desc = {= \meta{before code}}
}
  该选项用来设置在展示整个组之前需要执行的代码。
\end{option}

\begin{option}{
  opt = after-code,
  desc = {= \meta{after code}}
}
  该选项用来设置在展示整个组之后需要执行的代码。
\end{option}

\begin{option}{
  opt = item-code,
  desc = {= \meta{item code}}
}
  该选项用来设置展示组中每个元素的代码。你可以使用 \cs{rvuse} 来展示属性的值。
\end{option}

\begin{option}{
  opt = {\meta{attr}/before-code},
  desc = {= \meta{before code}}
}
  该选项用来设置展示组中属性 \meta{attr} 对应数据之前需要执行的代码。\cs{rvuse}
  会在展示属性数据前执行此代码。
\end{option}

\begin{option}{
  opt = {\meta{attr}/after-code},
  desc = {= \meta{after code}}
}
  该选项用来设置展示组中属性 \meta{attr} 对应数据之后需要执行的代码。\cs{rvuse}
  会在展示属性数据后执行此代码。
\end{option}

\begin{option}{
  opt = {\meta{attr}/sep},
  desc = {= \meta{sep spec}},
  init = {,~\~}
}
\begin{Syntax}
  \meta{attr}/sep = \meta{separator} \\
  \meta{attr}/sep = \{ \\
  ~~\meta{separator between two}, \\
  ~~\meta{separator between more than two}, \\
  ~~\meta{separator between final two} \\
  \}
\end{Syntax}

  该选项只适用于类型为 |clist| 的属性，用来设置列表间元素的间隔。第一个版本接
  受一个参数，将所有的元素间隔设置为 \meta{separator}。第二个版本接受逗号分隔
  的三个参数，分别用来设置只有两个元素时的分隔符 \meta{separator between two}，
  超过两个元素时的分隔符 \meta{separator between more than two}，和最后两个元
  素之间的分隔符 \meta{separator between final two}。

\end{option}

\begin{option}{
  opt = item-before-code,
  desc = {= \meta{before code}}
}
  该选项只适用于类型为 |clist| 的属性，用来设置展示列表每个元素前需要执行的代
  码。
\end{option}

\begin{option}{
  opt = item-after-code,
  desc = {= \meta{after code}}
}
  该选项只适用于类型为 |clist| 的属性，用来设置展示列表每个元素后需要执行的代
  码。
\end{option}

\subsection{使用 \cs{rvNewReviewPoints} 定义复习点}

\begin{function}{\rvNewReviewPoints}
  \begin{syntax}
    \cs{rvNewReviewPoints} \marg{name} \marg{points}
  \end{syntax}

  定义名为 \meta{name} 的复习点。这是专门为错题本或复习所定制的功能，
  \meta{points}是一系列整数，现在假设每道错题你都将写错时的日期记录在了 |date|
  属性中，并且你希望每隔2，5，15天复习一次。下面的代码给出了一个实现示例。
\begin{verbatim}
  \rvNewReviewPoints{review-point}{2, 5, 15}            % 定义复习点
  \begin{rvGroupFilters}
    \rvNewConditional{cond1}{date}{review-point|\Today} % 定义复习条件
    \rvCombineConditionals{filter1}{cond1}              % 定义过滤器
  \end{rvGroupFilters}
  \rvNewGroupStyle{review-style}{ques}{filter=filter1}  % 定义展示样式
\end{verbatim}
\end{function}

\subsection{在 \env{rvGroupFilters} 环境中定义过滤器}

\noindent\DescribeEnv{rvGroupFilters}
\begin{Syntax}*
  |\begin{rvGroupFilters}|\marg{group} \\
  ~~\meta{code}
  |\end{rvGroupFilters}| \\
\end{Syntax}

\env{rvGroupFilters}用来定义过滤器，此环境中定义了 \cs{rvNewConditional} 命令
用来定义条件和 \cs{rvCombineConditionals} 命令用来组合条件定义过滤器。过滤器独
立于每个 \meta{group}，这意味着你可以在不同组中定义名称相同的过滤条件和过滤器。

\begin{function}{\rvNewConditional, \rvNewConditional*}
  \begin{syntax}
    \cs{rvNewConditional}  \marg{name}        \marg{attr} \marg{cond spec} \\
    \cs{rvNewConditional}* \marg{name}        \marg{attr} \marg{cond spec} \\[2pt]
    \cs{rvNewConditional}  \marg{name} \marg{int/fp attr} \marg{relation} \\
    \cs{rvNewConditional}* \marg{name} \marg{int/fp attr} \marg{relation} \\
    \cs{rvNewConditional}  \marg{name} \marg{str/tl attr} \marg{regex expr} \\
    \cs{rvNewConditional}* \marg{name} \marg{str/tl attr} \marg{regex expr} \\
    \cs{rvNewConditional}  \marg{name}  \marg{clist attr} \marg{val list} \\
    \cs{rvNewConditional}* \marg{name}  \marg{clist attr} \marg{val list} \\
    \cs{rvNewConditional}  \marg{name}   \marg{date attr} \{\meta{review points}\textbar\meta{date}\} \\
    \cs{rvNewConditional}* \marg{name}   \marg{date attr} \marg{relation}
  \end{syntax}

  \cs{rvNewConditional} 用来定义名为 \meta{name} 的条件，\meta{attr} 指定条件
  所绑定的属性，在 \meta{cond spec} 中可以用 \cs{rval} 指代属性的值。
\end{function}

  对于类型为 |int| 和 |fp| 的属性，两个版本的定义是一致的，\meta{relation} 可
  以是单个关系式，比如 |\rval > 3|，也可以是组合关系式，比如
  |\rval > 3 && \rval < 10.2|。支持的操作符有 |<, >, =, ==, !=, >=, <=, !|。

  对于类型为 |str| 和 |tl| 的属性，\meta{regex} 为正则表达式，
  \cs{rvNewConditional} 表示部分匹配，\cs{rvNewConditional*} 表示整体匹配。
\begin{verbatim}
  \rvNewConditional{cond1}{str-attr}{abc}  % 匹配 abc, abcd, 1abc, =abc= 等
  \rvNewConditional*{cond2}{str-attr}{abc} % 只匹配 abc
\end{verbatim}

  对于类型为 |clist| 的属性，使用 \cs{rvNewConditional} 定义的条件只要
  \meta{val list} 中的任意一个元素在属性值（列表）中则条件成立；使用
  \cs{rvNewConditional*} 定义的条件只有 \meta{val list} 中每一个值都在属性值
  （列表）中条件才成立。

\begin{verbatim}
  \rvNewConditional{cond1}{clist-attr}{a, b, c}  % a, b, d 满足条件
  \rvNewConditional*{cond2}{clist-attr}{a, b, c} % a, b, d 不满足条件
\end{verbatim}

  对于类型为 |date| 的属性，\cs{rvNewConditional} 使用复习点来定义过滤条件，
  \meta{review points} 是 \cs{rvNewReviewPoints} 定义的复习点，\meta{date} 是
  用来比较的日期；\cs{rvNewConditional*} 使用\textbf{单个}关系式来定义过滤条件。
  支持的操作符有 |<, >, =, ==, !=, >=, <=|。

\begin{function}{\rvCombineConditionals}
  \begin{syntax}
    \cs{rvCombineConditionals} \marg{name} \marg{cond combination} \oarg{info}
  \end{syntax}

  \cs{rvCombineConditionals} 定义名为 \marg{name} 的过滤器，并将
  \cs{rvNewConditional} 定义的条件组合起来，比如
  \verb=\rvCombineConditionals{filter}{(cond1 && cond2) || !cond3}=。
  \meta{cond combination} 中可以使用的关系操作符为 \verb=&&, ||, !=。
  可以将 \opt{filter} 选项设置为 \meta{name} 来应用过滤器。\meta{info} 为过滤
  器的相关信息，在展示组的时候可以用 \cs{rvFilterInfo} 指代。
\end{function}

\subsection{使用 \env{rvitem} 环境存储数据}

\noindent\DescribeEnv{rvitem}
\begin{Syntax}*
  |\begin{rvitem}|\marg{group}[ \\
  ~~\meta{attr1} = \meta{val1}, \\
  ~~\meta{attr2} = \meta{val2}, \\
  ~~\ldots{} \\
  ] \\
  ~~\meta{code} \\
  |\end{rvitem}|
\end{Syntax}

  \env{rvitem} 环境用来存储数据。有两种存储数据的方法，较短的数据可以在选项列
  表中通过键值对设置值，较长的数据可以在 \meta{code} 中使用 \cs{rvsave} 存储。
  \cs{rvsave}会覆盖选项中设置的值。没有设置的值将会被设置为全局默认值，下面给
  出一个存储示例。

\begin{verbatim}
  \begin{rvitem}[date=2022-01-01, info=测试]
    \rvsave{question}{这是一个测试问题}
    \rvsave{answer}{这是一个测试答案}
  \end{rvitem}
\end{verbatim}

\subsection{\cs{rvsave} 和 \cs{rvuse}}

\begin{function}{\rvsave, \rvuse}
  \begin{syntax}
    \cs{rvsave} \marg{attr} \marg{data} \\
    \cs{rvuse}  \marg{attr} \\
  \end{syntax}

  \cs{rvsave} 用来存储数据，只能在 \env{item} 环境中使用。\cs{rvuse} 用来使用
  数据，只能在 \opt{item-code} 选项中使用。
\end{function}

\subsection{使用 \cs{rvshow} 展示组}

\begin{function}{\rvshow}
  \begin{syntax}
    \cs{rvshow} \marg{style} \marg{group}
  \end{syntax}

  使用 \meta{style} 样式来展示 \meta{group}。
\end{function}

\subsection{条件判别式}

\begin{function}{\rvIfEmptyT, \rvIfEmptyF, \rvIfEmptyTF}
  \begin{syntax}
    \cs{rvIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{rvIfEmptyT} \marg{true code} \\
    \cs{rvIfEmptyF} \marg{false code}
  \end{syntax}

  该判别式用来判断当前组是否为空。下面的示例展示了如何预防空的列表环境。
\end{function}

\begin{verbatim}
  \rvNewGroupStyle{style-cond1}{group-test}{
    before-code = {\rvIfEmptyF{\begin{enumerate}}},
    after-code = {\rvIfEmptyF{\end{enumerate}}},
    item-code = {\item \rvuse{attr-test}}
  }
\end{verbatim}

\begin{function}{\rvItemIfEmptyT, \rvItemIfEmptyF, \rvItemIfEmptyTF}
  \begin{syntax}
    \cs{rvItemIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{rvItemIfEmptyT} \marg{true code} \\
    \cs{rvItemIfEmptyF} \marg{false code}
  \end{syntax}

  该判别式用来判断当前元素是否为空。下面的示例展示了如何在展示 |group-test| 组
  中 |text| 属性的元素时在元素非空的时候前后都加上 |*|。
\end{function}

\begin{verbatim}
  \rvNewGroupStyle{style-cond2}{group-test}{
    text/before-code = {\rvItemIfEmptyF{*}},
    text/after-code = {\rvItemIfEmptyF{*}},
  }
\end{verbatim}

\begin{function}{\rvClistItemIfEmptyT, \rvClistItemIfEmptyF, \rvClistItemIfEmptyTF}
  \begin{syntax}
    \cs{rvClistItemIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{rvClistItemIfEmptyT} \marg{true code} \\
    \cs{rvClistItemIfEmptyF} \marg{false code}
  \end{syntax}

  该判别式用来判断列表属性中的元素是否为空。下面的示例展示了如何在展示 |group-test| 组
  中 |labels| 属性（标签列表）的元素时在标签非空的时候前后都加上 |*|。
\end{function}

\begin{verbatim}
  \rvNewGroup{group-test}{labels=clist}
  \rvNewGroupStyle{style-cond3}{group-test}{
    labels/item-before-code = {\rvClistItemIfEmptyF{*}},
    labels/item-after-code = {\rvClistItemIfEmptyF{*}},
  }
\end{verbatim}

\subsection{常量}

\begin{function}{\rvGroup, \rvFilterName, \rvFilterInfo, \rvIndex}
  \cs{rvGroup} 指代组名，\cs{rvFilterName} 指代过滤器名称，\cs{rvFilterInfo}
  指代过滤器额外信息，\cs{rvIndex} 指代当前索引。
\end{function}

\section{错题本示例}
见第 \ref{sec:example} 节。

\title{
  Package \pkg{review}
  \protect\footnote{\url{https://github.com/ZhiyuanLck/review}}
  \rlap{\makebox[4cm][r]{
    \normalsize $\Longrightarrow$ \color{red}
    \protect\hyperlink{zh}{中文版本}
    \protect\hypertarget{en}{}
  }}
}
\author{Li Changkai \texttt{<lichangkai225\@qq.com>}}
\date{2022/01/03}
\maketitle

\section{Introduction}

The initial motivation to write this package is that I want to write a
template, which can collect questions you gave the wrong answer and can
display those questions you would like to review by some conditionals, such as
questions with certain label, questions you have answered uncorrectly for
certain times or questions having not been reviewed for certain days. Well,
maybe I also want to sort the questions with certain order. I used to put much
effort into this specific goal and get a complicate template that is not easy
to use and extend.

Now the underlying logic is taken out from the old idea and is generized to
adapt to more situations. The current package is more than reviewing something,
but I still keep the "review" for its name.

The package provides four core functions: data storage and use, data filtering,
data sorting and data display. All data is saved once and then you can display
these data with custom filters, orders and styles.

The package constructs 6 types based on the internal typed of \pkg{expl3}:
\begin{Description}[\texttt{clist}]
  \item[\texttt{date}]
    date based on \pkg{datetime2} in iso format, supports comparison,
    sorting (converting to |str|), default \cs{Today}.
  \item[\texttt{str}]
    string，supports regex match and sorting, default empty.
  \item[\texttt{tl}]
    token list, supports regex match, default empty.
  \item[\texttt{int}]
    integer, supports comparison and sorting, default 0.
  \item[\texttt{fp}]
    floating point, supports comparison and sorting, default 0.
  \item[\texttt{clist}]
    comma list, default empty.
\end{Description}

\section{Interfaces}

\subsection{\cs{rvNewGroup}}

\begin{function}{\rvNewGroup, \rvNewGroup*}
  \begin{syntax}
    \cs{rvNewGroup} \oarg{base group} \marg{group} \{ \\
    ~~\meta{attr1} = \meta{type spec1}, \\
    ~~\meta{attr2} = \meta{type spec2}, \\
    ~~\ldots{} \\
    \} \\
    \cs{rvNewGroup}* \marg{group} \{ \\
    ~~\meta{attr1} = \meta{type spec1}, \\
    ~~\meta{attr2} = \meta{type spec2}, \\
    ~~\ldots{} \\
    \} \\
  \end{syntax}

\end{function}

Create a new group named \meta{group}, unstarred form provides the optional
\meta{base group} from which current group inherit the attributes settings.
The unstarred form always replace the old definition, while starred form
appends the new options.

\begin{Syntax}
  \meta{attr} = \meta{type} \\
  \meta{attr} = \meta{type}\textbar\meta{default}
\end{Syntax}

The first form defines the \meta{attr} as \meta{type}, and the second also
sets the default value.

\begin{note}
  Every group has a default attribute |id| to store the index of the item.
\end{note}

The example below define a group named |ques|.
\begin{verbatim}
  \rvNewGroup{ques}{
    question = tl, % store question
    answer = tl,   % store corresponding answer
    date = date,   % store the date when you were wrong
    info = tl,     % store extra info
    labels = clist % store question labels
  }
\end{verbatim}

\subsection{\cs{rvNewGroupStyle} and Style Options}

\begin{function}{\rvNewGroupStyle}
  \begin{syntax}
    \cs{rvNewGroupStyle} \oarg{base styles} \marg{style} \marg{group} \marg{opts}
  \end{syntax}

Define a new \meta{style} of \meta{group}. The style can inherit from a list
of \meta{base styles} such as
|\rvNewGroupStyle[base1, base2]{new-style}{ques}{}|.
\end{function}

\bigskip

\begin{option}{opt=filter, desc={= \meta{filter}}, init=-none-}
  Set the \meta{filter} defined by \cs{rvCombineFilters}.
\end{option}

\begin{option}{
  opt = sort,
  desc = {= \{ \meta{attr spec1}, \meta{attr spec2}, \ldots{} \}},
}
  Set sorting rules. Attributes of type |str, date, int, fp| is supported to
  sort.  Multi-level sort is allowed. \meta{attr} represents for ascending
  order, and \meta{attr}* represents for descending order. The example below
  use four fields to determine the order of the records. It sorts on |level|
  in descending order first and if two |levels| are same then sorts on |birth|
  in ascending order and so on.
\end{option}

\begin{verbatim}
  \rvNewGroup{sort-example}{
    name = str,
    birth = date,
    level = int,
    weight = fp,
  }
  \rvNewGroupStyle{sort-style}{sort-example}{
    sort = { level*, birth, name, weight }
  }
\end{verbatim}

\begin{option}{
  opt = before-code,
  desc = {= \meta{before code}}
}
  Set the \meta{before code} that is executed before displaying the group.
\end{option}

\begin{option}{
  opt = after-code,
  desc = {= \meta{after code}}
}
  Set the \meta{after code} that is executed after displaying the group.
\end{option}

\begin{option}{
  opt = item-code,
  desc = {= \meta{item code}}
}
  Set the code that show a single record. You can use \cs{rvuse} to display
  certian attribute.
\end{option}

\begin{option}{
  opt = {\meta{attr}/before-code},
  desc = {= \meta{before code}}
}
  Set the \meta{before code} that is executed by \cs{rvuse} before displaying
  certain attribute.
\end{option}

\begin{option}{
  opt = {\meta{attr}/after-code},
  desc = {= \meta{after code}}
}
  Set the \meta{after code} that is executed by \cs{rvuse} after displaying
  certain attribute.
\end{option}

\begin{option}{
  opt = {\meta{attr}/sep},
  desc = {= \meta{sep spec}},
  init = {,~\~}
}
\begin{Syntax}
  \meta{attr}/separator = \meta{separator} \\
  \meta{attr}/separator = \{ \\
  ~~\meta{separator between two}, \\
  ~~\meta{separator between more than two}, \\
  ~~\meta{separator between final two} \\
  \}
\end{Syntax}

  Only for attributes of type |clist|. Set the separator between clist items.
  The first form accept one arguments and set the seperator as \meta{sep}. The
  second form is more complicated, the following documentation is quoted from
  \pkg{interface3}:
  \begin{quote}
    If the comma list has more than two items, the \meta{separator between
    more than two} is placed between each pair of items except the last, for
    which the \meta{separator between final two} is used. If the comma list
    has exactly two items, then they are placed in the input stream separated
    by the \meta{separator between two}. If the comma list has a single item,
    it is placed in the input stream, and a comma list with no items produces
    no output.
  \end{quote}

\end{option}

\begin{option}{
  opt = item-before-code,
  desc = {= \meta{before code}}
}
  Only for attributes of type |clist|. Set the \meta{after code} that is
  excuted before displaying the item of the comma list.
\end{option}

\begin{option}{
  opt = item-after-code,
  desc = {= \meta{after code}}
}
  Only for attributes of type |clist|. Set the \meta{after code} that is
  excuted after displaying the item of the comma list.
\end{option}

\subsection{Use \cs{rvNewReviewPoints} to Define Review Points}

\begin{function}{\rvNewReviewPoints}
  \begin{syntax}
    \cs{rvNewReviewPoints} \marg{name} \marg{points}
  \end{syntax}

  Define the new \meta{points} that is specially designed for reviewing
  something. \meta{points} is a list of integers. Suppose you record the date
  when you did not answer correctly and you plan to review every 2, 5 and 15
  days. The following code give what you want.
\begin{verbatim}
  \rvNewReviewPoints{review-point}{2, 5, 15}            % define points
  \begin{rvGroupFilters}
    \rvNewConditional{cond1}{date}{review-point|\Today} % define conditional
    \rvCombineConditionals{filter1}{cond1}              % define filter
  \end{rvGroupFilters}
  \rvNewGroupStyle{review-style}{ques}{filter=filter1}  % define style
\end{verbatim}
\end{function}

\subsection{Define Filters inside \env{rvGroupFilters} Environment}

\noindent\DescribeEnv{rvGroupFilters}
\begin{Syntax}*
  |\begin{rvGroupFilters}|\marg{group} \\
  ~~\meta{code}
  |\end{rvGroupFilters}| \\
\end{Syntax}

Filters are defined inside \env{rvGroupFilters} environment, inside which,
\cs{rvNewConditional} is defined to declare conditionals and
\cs{rvCombineConditionals} is defined to combine conditionals. Filters are
independent in different groups, which means the same name of filters is
allowed in different groups.

\begin{function}{\rvNewConditional, \rvNewConditional*}
  \begin{syntax}
    \cs{rvNewConditional}  \marg{name}        \marg{attr} \marg{cond spec} \\
    \cs{rvNewConditional}* \marg{name}        \marg{attr} \marg{cond spec} \\[2pt]
    \cs{rvNewConditional}  \marg{name} \marg{int/fp attr} \marg{relation} \\
    \cs{rvNewConditional}* \marg{name} \marg{int/fp attr} \marg{relation} \\
    \cs{rvNewConditional}  \marg{name} \marg{str/tl attr} \marg{regex expr} \\
    \cs{rvNewConditional}* \marg{name} \marg{str/tl attr} \marg{regex expr} \\
    \cs{rvNewConditional}  \marg{name}  \marg{clist attr} \marg{val list} \\
    \cs{rvNewConditional}* \marg{name}  \marg{clist attr} \marg{val list} \\
    \cs{rvNewConditional}  \marg{name}   \marg{date attr} \{\meta{review points}\textbar\meta{date}\} \\
    \cs{rvNewConditional}* \marg{name}   \marg{date attr} \marg{relation}
  \end{syntax}

  Define the conditional named \meta{name} that binds to \meta{attr}. \cs{rval}
  is replaced with the real value of the attribute inside the \meta{cond spec}.
\end{function}

For attributes of type |int| and |fp|, two forms have the same definition.
\meta{relation} can be a single relation formula, such as |\rval > 3|, or the
combination of several relation formulas, such as |\rval > 3 && \rval < 10.2|.
Supported operators are |<, >, =, ==, !=, >=, <=, !|.

For attribute of type |str| and |tl|, unstarred form matches any part while
starred form matches the whole part with the \meta{regex expr}.
\begin{verbatim}
  \rvNewConditional{cond1}{str-attr}{abc}  % match abc, abcd, 1abc, =abc=, etc
  \rvNewConditional*{cond2}{str-attr}{abc} % only match abc
\end{verbatim}

For attributes of type |clist|, the conditional defined by unstarred form is
true if any item of \meta{val list} is in the comma list. While the
conditional defined by starred form is true only if every item of \meta{val
list} is in the comma list. As is showed below, for |cond1|, |a| is in
|{a, b, d}| so |cond1| is true. While |c| is not in |{a, b, d}| so |cond2| is
false.

\begin{verbatim}
  \rvNewConditional{cond1}{clist-attr}{a, b, c}  % {a, b, d} -> true
  \rvNewConditional*{cond2}{clist-attr}{a, b, c} % {a, b, d} -> false
\end{verbatim}

For attributes of type |date|, unstarred form uses \meta{review points} to
define the conditional and \meta{date} is the date to be compared. The starred
form define the conditional with \textbf{single} relation formula. Supported
operators are |<, >, =, ==, !=, >=, <=|.

\begin{function}{\rvCombineConditionals}
  \begin{syntax}
    \cs{rvCombineConditionals} \marg{name} \marg{cond combination} \oarg{info}
  \end{syntax}

  Define the filter \meta{name}, which combine the conditionals and store the
  extra \meta{info} into \cs{rvFilterInfo}. So you can write something as\\
  \verb=\rvCombineConditionals{filter}{(cond1 && cond2) || !cond3}=.\\
  Supported operators are \verb=&&, ||, !=. You can set the option \opt{filter}
  to \meta{name} to apply the filter when you display the group.
\end{function}

\subsection{Store Data with \env{rvitem} Environment}

\noindent\DescribeEnv{rvitem}
\begin{Syntax}*
  |\begin{rvitem}|\marg{group}[ \\
  ~~\meta{attr1} = \meta{val1}, \\
  ~~\meta{attr2} = \meta{val2}, \\
  ~~\ldots{} \\
  ] \\
  ~~\meta{code} \\
  |\end{rvitem}|
\end{Syntax}

The data are stored with \env{rvitem} environment in two ways. Smaller data
can be stored in the option list and the bigger data can be stored by
\cs{rvsave}, which will suppress the value set by the option list. An example
code is showned below.

\begin{verbatim}
  \begin{rvitem}[date=2022-01-01, info=test]
    \rvsave{question}{This is a test question.}
    \rvsave{answer}{This is the correct answer of the question.}
  \end{rvitem}
\end{verbatim}

\subsection{\cs{rvsave} and \cs{rvuse}}

\begin{function}{\rvsave, \rvuse}
  \begin{syntax}
    \cs{rvsave} \marg{attr} \marg{data} \\
    \cs{rvuse}  \marg{attr} \\
  \end{syntax}

  Date is stored with \cs{rvsave} and is displayed with \cs{rvuse}.  \cs{rvsave}
  can be used only inside the \env{rvitem} environment and \cs{rvuse} can be
  only used inside the option \opt{item-code}.
\end{function}

\subsection{Use \cs{rvshow} to Display the Group}

\begin{function}{\rvshow}
  \begin{syntax}
    \cs{rvshow} \marg{style} \marg{group}
  \end{syntax}

  Show the \meta{group} with \meta{style}.
\end{function}

\subsection{Conditionals}

\begin{function}{\rvIfEmptyT, \rvIfEmptyF, \rvIfEmptyTF}
  \begin{syntax}
    \cs{rvIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{rvIfEmptyT} \marg{true code} \\
    \cs{rvIfEmptyF} \marg{false code}
  \end{syntax}

  Test if the group is empty. The example below shows how to avoid an empty
  list environment.
\end{function}

\begin{verbatim}
  \rvNewGroupStyle{style-cond1}{group-test}{
    before-code = {\rvIfEmptyF{\begin{enumerate}}},
    after-code = {\rvIfEmptyF{\end{enumerate}}},
    item-code = {\item \rvuse{attr-test}}
  }
\end{verbatim}

\begin{function}{\rvItemIfEmptyT, \rvItemIfEmptyF, \rvItemIfEmptyTF}
  \begin{syntax}
    \cs{rvItemIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{rvItemIfEmptyT} \marg{true code} \\
    \cs{rvItemIfEmptyF} \marg{false code}
  \end{syntax}

  Test if the value of the attribute is empty. The example belows shows how to
  surround the non-empty |text| attribute with the symbol *.
\end{function}

\begin{verbatim}
  \rvNewGroupStyle{style-cond2}{group-test}{
    text/before-code = {\rvItemIfEmptyF{*}},
    text/after-code = {\rvItemIfEmptyF{*}},
  }
\end{verbatim}

\begin{function}{\rvClistItemIfEmptyT, \rvClistItemIfEmptyF, \rvClistItemIfEmptyTF}
  \begin{syntax}
    \cs{rvClistItemIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{rvClistItemIfEmptyT} \marg{true code} \\
    \cs{rvClistItemIfEmptyF} \marg{false code}
  \end{syntax}

  Test if the item of comma list is empty. The example belows shows how to
  surround the non-empty label with the symbol *.
\end{function}

\begin{verbatim}
  \rvNewGroup{group-test}{labels=clist}
  \rvNewGroupStyle{style-cond3}{group-test}{
    labels/item-before-code = {\rvClistItemIfEmptyF{*}},
    labels/item-after-code = {\rvClistItemIfEmptyF{*}},
  }
\end{verbatim}

\subsection{Constants}

\begin{function}{\rvGroup, \rvFilterName, \rvFilterInfo, \rvIndex}
  \cs{rvGroup} represents for the group name, \cs{rvFilterName} represents for
  the filter name, \cs{rvFilterInfo} represents for the extra info of the
  filter and \cs{rvIndex} represents for the item index.
\end{function}

\section{Example of Flaw Sweeper Template}
\label{sec:example}

\begin{verbatim}
  \documentclass{article}
  \usepackage{review}
  \usepackage{hyperref}

  \NewDocumentCommand { \hyperlinktarget } { m m m } {%
    \hyperlink{#1}{#3}\hypertarget{#2}{}
  }

  \rvNewGroup{ques}{
    question=tl,
    answer=tl,
    date=date,
    count=int,
    labels=clist
  }
  \rvNewReviewPoints{review}{1, 3, 7, 15, 30, 60}

  \begin{rvGroupFilters}{ques}
    % which need reviewed today?
    \rvNewConditional{date}{date}{review|2021-12-25}
    \rvNewConditional{easy}{labels}{easy}
    \rvNewConditional{not-easy}{labels}{mid, hard}
    % questions you haven't answered correctly for more than 3 times!
    \rvNewConditional{bad}{count}{\rval > 3}
    \rvCombineConditionals{date}{date}[to be review today]
    \rvCombineConditionals{easy}{easy}[easy questions]
    \rvCombineConditionals{not-easy}{not-easy}[hard questions]
    \rvCombineConditionals{bad}{bad}[bad questions]
    \rvCombineConditionals{bad-easy}{bad && easy}[bad but easy questions]
  \end{rvGroupFilters}

  \newcounter{ques}

  \rvNewGroupStyle{test}{ques} {
    before-code = {\setcounter{ques}{0}\section{Test}},
    item-code = {
      \refstepcounter{ques}
      \par\noindent\arabic{ques}. \rvuse{labels} \rvuse{date}\hfill \rvuse{count}
      \par\noindent ques: \rvuse{question}
      \par\noindent\hyperlinktarget
        {answer_\rvIndex}{ques_\rvIndex}{go to answer}
    },
  }
  \rvNewGroupStyle{check}{ques} {
    before-code = {\setcounter{ques}{0}\section{Answer}},
    item-code = {
      \refstepcounter{ques}
      \par\noindent\arabic{ques}. \rvuse{labels} \rvuse{date}\hfill \rvuse{count}
      \par\noindent ques: \rvuse{question}
      \par\noindent\hyperlinktarget
        {ques_\rvIndex}{answer_\rvIndex}{back to question}
      \par\noindent answer: \rvuse{answer}
    },
  }
  \rvNewGroupStyle[test]{test-bad}{ques}{
    filter=bad,
    before-code = {\setcounter{ques}{0}\section{Bad Question}}
  }

  \AtEndDocument{
    \rvshow{test}{ques}
    \rvshow{test-bad}{ques}
    \rvshow{check}{ques}
  }

  \begin{document}

  \begin{rvitem}{ques}[date=2021-12-21, count=1, labels=easy]
    \rvsave{question}{This is test question 1.}
    \rvsave{answer}{This is test question 1.}
  \end{rvitem}

  \begin{rvitem}{ques}[date=2021-12-22, count=4, labels=easy]
    \rvsave{question}{This is test question 2.}
    \rvsave{answer}{This is test question 2.}
  \end{rvitem}

  \begin{rvitem}{ques}[date=2021-12-23, count=3, labels=hard]
    \rvsave{question}{This is test question 3.}
    \rvsave{answer}{This is test question 3.}
  \end{rvitem}

  \end{document}
\end{verbatim}

\end{documentation}


\end{document}
