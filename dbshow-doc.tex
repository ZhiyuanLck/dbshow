\documentclass[full]{l3doc}
\usepackage[scheme=plain]{ctex}
\usepackage{zhlineskip}
\usepackage{enumitem}
\usepackage{indentfirst}
\usepackage{titling}
\usepackage{geometry}
\usepackage{tabularray}
\usepackage{xcolor}
\usepackage{tcolorbox}
\tcbuselibrary{listings, skins, raster, breakable}
\usepackage{tabularray}

\def\zhdate{2022年1月7日}
\def\endate{2022/01/07}

\IndexPrologue
  {
    \section*{Index}
    \markboth{Index}{Index}
    \addcontentsline{toc}{section}{Index}
    The~italic~numbers~denote~the~pages~where~the~
    corresponding~entry~is~described,~
    numbers~underlined~point~to~the~definition,~
    all~others~indicate~the~places~where~it~is~used.
  }

\newcommand\tikzmark[1]{\tikz \coordinate[overlay, remember picture] (#1);}

\geometry{
  left=4.5cm,
  right=2cm,
  top=2cm,
  bottom=2cm,
}
\hypersetup {
  CJKbookmarks,
  bookmarksopen,
  bookmarksopenlevel=3,
  pdfstartview=FitH,
  pdfinfo = {
   Title = The package 'dbshow' ,
   Subject = A LaTeX package ,
   Author = Li Changkai
 }
}

\DoNotIndex{\begin, \end}
\setlength{\parskip}{\medskipamount}
\DeclareDocumentEnvironment { note } { +b } {
  \par\textbf{\textsf{NOTE:~}}#1\par
} {}

\AtEndDocument{
  \newgeometry{
    left=2cm,
    right=2cm,
    top=2cm,
    bottom=2cm
  }
  \PrintIndex
}

\ExplSyntaxOn
\NewDocumentCommand { \strcs } { m } {
  \texttt{\tl_to_str:n { #1 }}
}

\dim_new:N \l__my_syntax_dim
\box_new:N \g__my_syntax_box
\NewDocumentEnvironment { Syntax } { s }
  {
    \dim_set:Nn \l__my_syntax_dim
      { \textwidth }
    \hbox_gset:Nw \g__my_syntax_box
      \small \ttfamily
      \begin{minipage}[t]{\l__my_syntax_dim}
        \raggedright\obeyspaces\obeylines
  }
  {
      \end{minipage}
    \hbox_gset_end:
    \IfValueF { #1 } { \smallskip }
    \box_use_drop:N \g__my_syntax_box
    \smallskip
  }

\DeclareDocumentEnvironment { Description } { o +b } {
  \hbox_set:Nn \l_tmpa_box { #1 }
  \dim_set:Nn \l_tmpa_dim { \box_wd:N \l_tmpa_box }
  \begin{itemize}[labelwidth=\l_tmpa_dim, align=left]
    #2
  \end{itemize}
} {  }

\keys_define:nn { dbshow/doc } {
  opt .tl_set:N = \l_opt_tl,
  desc .tl_set:N = \l_desc_tl,
  init .tl_set:N = \l_init_tl,
  init .initial:n = init-none,
}

\box_new:N \l__option_box
\NewDocumentEnvironment { option } { m +b } {
  \keys_set:nn { dbshow/doc } { #1 }
  \hbox_set:Nw \l__option_box
    \small \ttfamily
    \begin{minipage}[t]{\textwidth}
      \obeyspaces\obeylines
      \textcolor{red}{
        \l_opt_tl
        \exp_args:Nx\SpecialOptionIndex{\l_opt_tl}
      }
      {~}\l_desc_tl
      \hfill(
      \tl_if_eq:NnTF \l_init_tl { init-none } { no~value }
        { initially~\texttt{\l_init_tl} }
      )
    \end{minipage}
  \hbox_gset_end:
  \box_use_drop:N \l__option_box
  #2
  \medskip
} {  }

\DeclareDocumentCommand \opt { O{} m }
  { \__codedoc_cmd:no {#1} { #2 } }
\ExplSyntaxOff


\begin{document}
\title{
  \pkg{dbshow} 宏包
  \protect\footnote{%
    代码仓库：\url{https://github.com/ZhiyuanLck/dbshow}，
    QQ群：788706534}
  \rlap{\makebox[4cm][r]{
    \normalsize $\Longrightarrow$ \color{red}
    \protect\hyperlink{en}{English Version}
    \protect\hypertarget{zh}{}
  }}
}
\author{\textit{李昌锴} \texttt{<lichangkai225@qq.com>}}
\date{\zhdate}
\maketitle

\tableofcontents

\begin{documentation}

\section{引言}
编写本宏包的动机来源于当前没有一个很好的错题本宏包，可以方便的根据各种条件对错
题进行筛选、排序，然后以自定义的样式展示出来。\pkg{dbshow} 宏包实现了四个核心
功能：数据存储和使用、数据筛选、数据排序、数据展示。

数据只需要存储一次，就可以通过预定义的筛选、排序条件和样式展示部分或全部的数据。
如上所述，本宏包其实实现了一个非常简单的数据库，复习错题的功能只是其中一个应用，
和其他数据库宏包比如 \pkg{datatool} 相比，\pkg{dbshow} 更专注于非图表类型的数
据展示。

宏包基于 \pkg{expl3} 的基础类型构建了6种类型：
\begin{Description}[\texttt{clist}]
  \item[\texttt{date}]
    基于宏包 \pkg{datetime2} 的日期类型，以iso标准存储，支持大小比较，排序（转
    换成字符串）。默认值为 \cs{Today}。
  \item[\texttt{str}]
    字符串类型，支持正则匹配，英文排序。默认值为空。
  \item[\texttt{tl}]
    \meta{token list}类型，支持正则匹配。默认值为空。
  \item[\texttt{int}]
    整数类型，支持大小比较，排序。默认值为0。
  \item[\texttt{fp}]
    浮点数类型，支持大小比较，排序。默认值为0。
  \item[\texttt{clist}]
    逗号分隔的列表类型。默认值为空列表。
\end{Description}

\section{接口文档}

\subsection{创建、展示和清空数据库}
\begin{function}{\dbNewDatabase, \dbNewDatabase*}
  \begin{syntax}
    \cs{dbNewDatabase} \oarg{base database} \marg{database} \{ \\
    ~~\meta{attr1} = \meta{type spec1}, \\
    ~~\meta{attr2} = \meta{type spec2}, \\
    ~~\ldots{} \\
    \} \\
    \cs{dbNewDatabase}* \marg{database} \{ \\
    ~~\meta{attr1} = \meta{type spec1}, \\
    ~~\meta{attr2} = \meta{type spec2}, \\
    ~~\ldots{} \\
    \} \\
  \end{syntax}

\end{function}

  新建一个数据库，不带星号的版本可以指定一个数据库来继承其属性设置，该版本总是
  会舍弃掉之前的定义。

  带星号的版本不会舍弃之前已有的定义，而是将新的选项添加到后面。

  \meta{attr} 为属性名称，\meta{type spec} 负责声明属性类型和属性默认值：

  \noindent\begin{tblr}{
    colspec = {ll},
    column{1} = {font = \ttfamily}
  }
    \meta{attr} = \meta{type} &
    将 \meta{attr} 声明为 \meta{type} 类型 \\
    \meta{attr} = \meta{type}\textbar\meta{default} &
    将 \meta{attr} 声明为 \meta{type} 类型，并且将默认值设置为 \meta{default}。
    \\
  \end{tblr}

  \begin{note}
    每个数据库都有一个默认的属性 |id| 用来存储数据的索引。
  \end{note}

  下面是定义一个错题数据库的示例，|question| 和 |answer| 属性用来存储问题和答
  案，|date| 属性存储日期，|info| 属性存储额外信息，|labels| 存储题目标签。
\begin{verbatim}
  \dbNewDatabase{ques}{
    question = tl,
    answer = tl,
    date = date,
    info = tl,
    labels = clist
  }
\end{verbatim}

\begin{function}{\dbshow}
  \begin{syntax}
    \cs{dbshow} \marg{style} \marg{database}
  \end{syntax}

  使用 \meta{style} 样式来展示 \meta{database}。
\end{function}

\begin{function}{\dbclear}
  \begin{syntax}
    \cs{dbclear} \marg{database}
  \end{syntax}

  清空 \meta{database} 里的所有内容。

\end{function}

\subsection{\cs{dbNewStyle} 和样式选项}

\begin{function}{\dbNewStyle}
  \begin{syntax}
    \cs{dbNewStyle} \oarg{base styles} \marg{style} \marg{database} \marg{opts}
  \end{syntax}

  为 \meta{database} 定义一个新的样式 \meta{style}，该样式可以基于已有的样式
  \meta{base styles}，比如 |\dbNewStyle[base1, base2]{new-style}{ques}{}|。
\end{function}

\bigskip

\begin{option}{opt=filter, desc={= \meta{filter}}, init=-none-}
  为当前样式设置由 \cs{dbCombineFilters} 所定义的过滤器
\end{option}

\begin{option}{opt=raw-filter, desc={= \meta{cond combination}}}
  用已定义的条件为当前样式设置匿名过滤器。下面两个例子的作用是等同的。
\end{option}

\begin{verbatim}
  % method 1
  \begin{dbFilters}{db}
    \dbNewConditional{cond1}{int-attr}{\rval > 1}
    \dbNewConditional*{cond2}{str-attr}{\d+}
  \end{dbFilters}
  \dbNewStyle{style}{db}{raw-filter={cond1 && cond2}}
  % method 2
  \begin{dbFilters}{db}
    \dbNewConditional{cond1}{int-attr}{\rval > 1}
    \dbNewConditional*{cond2}{str-attr}{\d+}
    \dbCombineFilters{filter}{cond1 && cond2}
  \end{dbFilters}
  \dbNewStyle{style}{db}{filter=filter}
\end{verbatim}

\begin{option}{
  opt = sort,
  desc = {= \{ \meta{attr spec1}, \meta{attr spec2}, \ldots{} \}},
}
  为当前样式设置排序规则。支持根据 |str|，|date|，|int|，|fp| 类型的数据进行排
  序，支持多级排序。\meta{attr} 表示增序，\meta{attr}* 表示降序。下面例子中，
  使用 |sort-style| 展示数据时的顺序为先按 |level| 降序，|level| 相同的再按出
  生日期 |birth| 增序，以此类推。
\end{option}

\begin{verbatim}
  \dbNewDatabase{sort-example}{
    name = str,
    birth = date,
    level = int,
    weight = fp,
  }
  \dbNewStyle{sort-style}{sort-example}{
    sort = { level*, birth, name, weight }
  }
\end{verbatim}

\begin{option}{
  opt = before-code,
  desc = {= \meta{before code}}
}
  该选项用来设置在展示整个数据库之前需要执行的代码。
\end{option}

\begin{option}{
  opt = after-code,
  desc = {= \meta{after code}}
}
  该选项用来设置在展示整个数据库之后需要执行的代码。
\end{option}

\begin{option}{
  opt = item-code,
  desc = {= \meta{item code}}
}
  该选项用来设置展示数据库中每条记录的代码。你可以使用 \cs{dbuse} 来展示属性的
  值。
\end{option}

\begin{option}{
  opt = {\meta{attr}/before-code},
  desc = {= \meta{before code}}
}
  该选项用来设置展示数据库中属性 \meta{attr} 对应数据之前需要执行的代码。
  \cs{dbuse} 会在展示属性数据前执行此代码。
\end{option}

\begin{option}{
  opt = {\meta{attr}/after-code},
  desc = {= \meta{after code}}
}
  该选项用来设置展示数据库中属性 \meta{attr} 对应数据之后需要执行的代码。
  \cs{dbuse} 会在展示属性数据后执行此代码。
\end{option}

\begin{option}{
  opt = {\meta{attr}/sep},
  desc = {= \meta{sep spec}},
  init = {,~\~}
}
\begin{Syntax}
  \meta{attr}/sep = \meta{separator} \\
  \meta{attr}/sep = \{ \\
  ~~\meta{separator between two}, \\
  ~~\meta{separator between more than two}, \\
  ~~\meta{separator between final two} \\
  \}
\end{Syntax}

  该选项只适用于类型为 |clist| 的属性，用来设置列表间元素的间隔。第一个版本接
  受一个参数，将所有的元素间隔设置为 \meta{separator}。第二个版本接受逗号分隔
  的三个参数，分别用来设置只有两个元素时的分隔符 \meta{separator between two}，
  超过两个元素时的分隔符 \meta{separator between more than two}，和最后两个元
  素之间的分隔符 \meta{separator between final two}。

\end{option}

\begin{option}{
  opt = item-before-code,
  desc = {= \meta{before code}}
}
  该选项只适用于类型为 |clist| 的属性，用来设置展示列表每个元素前需要执行的代
  码。
\end{option}

\begin{option}{
  opt = item-after-code,
  desc = {= \meta{after code}}
}
  该选项只适用于类型为 |clist| 的属性，用来设置展示列表每个元素后需要执行的代
  码。
\end{option}

\subsection{使用 \cs{dbNewReviewPoints} 定义复习点}

\begin{function}{\dbNewReviewPoints}
  \begin{syntax}
    \cs{dbNewReviewPoints} \marg{name} \marg{points}
  \end{syntax}

  定义名为 \meta{name} 的复习点。这是专门为错题本或复习所定制的功能，
  \meta{points}是一系列整数，现在假设每道错题你都将写错时的日期记录在了 |date|
  属性中，并且你希望每隔2，5，15天复习一次。下面的代码给出了一个实现示例。
\begin{verbatim}
  \dbNewReviewPoints{review-point}{2, 5, 15}            % 定义复习点
  \begin{dbFilters}
    \dbNewConditional{cond1}{date}{review-point|\Today} % 定义复习条件
    \dbCombineConditionals{filter1}{cond1}              % 定义过滤器
  \end{dbFilters}
  \dbNewStyle{review-style}{ques}{filter=filter1}       % 定义展示样式
\end{verbatim}
\end{function}

\subsection{在 \env{dbFilters} 环境中定义过滤器}

\noindent\DescribeEnv{dbFilters}
\begin{Syntax}*
  |\begin{dbFilters}|\marg{database} \\
  ~~\meta{code}
  |\end{dbFilters}| \\
\end{Syntax}

\env{dbFilters}用来定义过滤器，此环境中定义了 \cs{dbNewConditional} 命令用来定
义条件和 \cs{dbCombineConditionals} 命令用来组合条件定义过滤器。过滤器独立于每
个 \meta{database}，这意味着你可以在不同数据库中定义名称相同的过滤条件和过滤器。

\begin{function}{\dbNewConditional, \dbNewConditional*}
  \begin{syntax}
    \cs{dbNewConditional}  \marg{name}        \marg{attr} \marg{cond spec} \\
    \cs{dbNewConditional}* \marg{name}        \marg{attr} \marg{cond spec} \\[2pt]
    \cs{dbNewConditional}  \marg{name} \marg{int/fp attr} \marg{relation} \\
    \cs{dbNewConditional}* \marg{name} \marg{int/fp attr} \marg{relation} \\
    \cs{dbNewConditional}  \marg{name} \marg{str/tl attr} \marg{regex expr} \\
    \cs{dbNewConditional}* \marg{name} \marg{str/tl attr} \marg{regex expr} \\
    \cs{dbNewConditional}  \marg{name}  \marg{clist attr} \marg{val list} \\
    \cs{dbNewConditional}* \marg{name}  \marg{clist attr} \marg{val list} \\
    \cs{dbNewConditional}  \marg{name}   \marg{date attr} \{\meta{review points}\textbar\meta{date}\} \\
    \cs{dbNewConditional}* \marg{name}   \marg{date attr} \marg{relation}
  \end{syntax}

  \cs{dbNewConditional} 用来定义名为 \meta{name} 的条件，\meta{attr} 指定条件
  所绑定的属性，在 \meta{cond spec} 中可以用 \cs{dbval} 指代属性的值。
\end{function}

  对于类型为 |int| 和 |fp| 的属性，两个版本的定义是一致的，\meta{relation} 可
  以是单个关系式，比如 |\dbval > 3|，也可以是组合关系式，比如
  |\dbval > 3 && \dbval < 10.2|。支持的操作符有 |<, >, =, ==, !=, >=, <=, !|。

  对于类型为 |str| 和 |tl| 的属性，\meta{regex} 为正则表达式，
  \cs{dbNewConditional} 表示部分匹配，\cs{dbNewConditional*} 表示整体匹配。
\begin{verbatim}
  \dbNewConditional{cond1}{str-attr}{abc}  % 匹配 abc, abcd, 1abc, =abc= 等
  \dbNewConditional*{cond2}{str-attr}{abc} % 只匹配 abc
\end{verbatim}

  对于类型为 |clist| 的属性，使用 \cs{dbNewConditional} 定义的条件只要
  \meta{val list} 中的任意一个元素在属性值（列表）中则条件成立；使用
  \cs{dbNewConditional*} 定义的条件只有 \meta{val list} 中每一个值都在属性值
  （列表）中条件才成立。

\begin{verbatim}
  \dbNewConditional{cond1}{clist-attr}{a, b, c}  % a, b, d 满足条件
  \dbNewConditional*{cond2}{clist-attr}{a, b, c} % a, b, d 不满足条件
\end{verbatim}

  对于类型为 |date| 的属性，\cs{dbNewConditional} 使用复习点来定义过滤条件，
  \meta{review points} 是 \cs{dbNewReviewPoints} 定义的复习点，\meta{date} 是
  用来比较的日期；\cs{dbNewConditional*} 使用\textbf{单个}关系式来定义过滤条件。
  支持的操作符有 |<, >, =, ==, !=, >=, <=|。

\begin{function}{\dbCombineConditionals}
  \begin{syntax}
    \cs{dbCombineConditionals} \marg{name} \marg{cond combination} \oarg{info}
  \end{syntax}

  \cs{dbCombineConditionals} 定义名为 \marg{name} 的过滤器，并将
  \cs{dbNewConditional} 定义的条件组合起来，比如
  \verb=\dbCombineConditionals{filter}{(cond1 && cond2) || !cond3}=。
  \meta{cond combination} 中可以使用的关系操作符为 \verb=&&, ||, !=。
  可以将 \opt{filter} 选项设置为 \meta{name} 来应用过滤器。\meta{info} 为过滤
  器的相关信息，在展示数据库的时候可以用 \cs{dbFilterInfo} 指代。
\end{function}

\subsection{使用 \env{dbitem} 环境存储数据}

\noindent\DescribeEnv{dbitem}
\begin{Syntax}*
  |\begin{dbitem}|\marg{database}[ \\
  ~~\meta{attr1} = \meta{val1}, \\
  ~~\meta{attr2} = \meta{val2}, \\
  ~~\ldots{} \\
  ] \\
  ~~\meta{code} \\
  |\end{dbitem}|
\end{Syntax}

  \env{dbitem} 环境用来存储数据。有两种存储数据的方法，较短的数据可以在选项列
  表中通过键值对设置值，较长的数据可以在 \meta{code} 中使用 \cs{dbsave} 存储。
  \cs{dbsave}会覆盖选项中设置的值。没有设置的值将会被设置为全局默认值，下面给
  出一个存储示例。

\begin{verbatim}
  \begin{dbitem}[date=2022-01-01, info=测试]
    \dbsave{question}{这是一个测试问题}
    \dbsave{answer}{这是一个测试答案}
  \end{dbitem}
\end{verbatim}

\subsection{\cs{dbsave} 和 \cs{dbuse}}

\begin{function}{\dbsave, \dbuse}
  \begin{syntax}
    \cs{dbsave} \marg{attr} \marg{data} \\
    \cs{dbuse}  \marg{attr} \\
  \end{syntax}

  \cs{dbsave} 用来存储数据，只能在 \env{item} 环境中使用。\cs{dbuse} 用来使用
  数据，只能在 \opt{item-code} 选项中使用。
\end{function}

\subsection{条件判别式}

\begin{function}{\dbIfEmptyT, \dbIfEmptyF, \dbIfEmptyTF}
  \begin{syntax}
    \cs{dbIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{dbIfEmptyT} \marg{true code} \\
    \cs{dbIfEmptyF} \marg{false code}
  \end{syntax}

  该判别式用来判断当前数据库是否为空。下面的示例展示了如何预防空的列表环境。
\end{function}

\begin{verbatim}
  \dbNewStyle{style-cond1}{database-test}{
    before-code = {\dbIfEmptyF{\begin{enumerate}}},
    after-code = {\dbIfEmptyF{\end{enumerate}}},
    item-code = {\item \dbuse{attr-test}}
  }
\end{verbatim}

\begin{function}{\dbItemIfEmptyT, \dbItemIfEmptyF, \dbItemIfEmptyTF}
  \begin{syntax}
    \cs{dbItemIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{dbItemIfEmptyT} \marg{true code} \\
    \cs{dbItemIfEmptyF} \marg{false code}
  \end{syntax}

  该判别式用来判断当前元素是否为空。下面的示例展示了如何在展示 |database-test|
  数据库中 |text| 属性的元素时在元素非空的时候前后都加上 |*|。
\end{function}

\begin{verbatim}
  \dbNewStyle{style-cond2}{database-test}{
    text/before-code = {\dbItemIfEmptyF{*}},
    text/after-code = {\dbItemIfEmptyF{*}},
  }
\end{verbatim}

\begin{function}{\dbClistItemIfEmptyT, \dbClistItemIfEmptyF, \dbClistItemIfEmptyTF}
  \begin{syntax}
    \cs{dbClistItemIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{dbClistItemIfEmptyT} \marg{true code} \\
    \cs{dbClistItemIfEmptyF} \marg{false code}
  \end{syntax}

  该判别式用来判断列表属性中的元素是否为空。下面的示例展示了如何在展示
  |database-test| 数据库中 |labels| 属性（标签列表）的元素时在标签非空的时候前
  后都加上 |*|。
\end{function}

\begin{verbatim}
  \dbNewDatabase{database-test}{labels=clist}
  \dbNewStyle{style-cond3}{database-test}{
    labels/item-before-code = {\dbClistItemIfEmptyF{*}},
    labels/item-after-code = {\dbClistItemIfEmptyF{*}},
  }
\end{verbatim}

\subsection{特殊命令}

\pkg{dbshow} 定义了一些特殊的命令，会根据语境展开为不同的内容。

\DescribeMacro{\dbval}当前属性的值，只能在 \cs{dbNewConditional} 中使用

\DescribeMacro{\dbDatabase}数据库名称

\DescribeMacro{\dbFilterName}过滤器名称

\DescribeMacro{\dbFilterInfo}过滤器信息

\DescribeMacro{\dbIndex}原始数据索引，等同于 |\dbuse{id}| 但是 \cs{dbuse} 是不可展开的

\DescribeMacro{\dbarabic}用数字表示的查询集数据计数

\DescribeMacro{\dbalph}用小写字母表示的查询集数据计数

\DescribeMacro{\dbAlph}用小写字母表示的查询集数据计数

\DescribeMacro{\dbroman}用小写罗马数字表示的查询集数据计数

\DescribeMacro{\dbRoman}用大写罗马数字表示的查询集数据计数

\section{错题本示例}
见第 \ref{sec:example} 节。

\title{
  Package \pkg{dbshow}
  \protect\footnote{%
    Repository: \url{https://github.com/ZhiyuanLck/dbshow},
    Telegram Group: \url{https://t.me/latex_dbshow}}
  \rlap{\makebox[4cm][r]{
    \normalsize $\Longrightarrow$ \color{red}
    \protect\hyperlink{zh}{中文版本}
    \protect\hypertarget{en}{}
  }}
}
\author{Li Changkai \texttt{<lichangkai225@qq.com>}}
\date{\endate}
\maketitle

\section{Introduction}

The initial motivation to write this package is that I want to write a
template, which can collect questions you gave the wrong answer and can
display those questions you would like to review by some conditionals, such as
questions with certain label, questions you have answered uncorrectly for
certain times or questions having not been reviewed for certain days. So this
package provides a database to do such thing.

The package provides four core functions: data storage and display, data
filtering, data sorting and data display. All data is saved once and then you
can display these data with custom filters, orders and styles.

The package constructs 6 types based on the internal typed of \pkg{expl3}:
\begin{Description}[\texttt{clist}]
  \item[\texttt{date}]
    date based on \pkg{datetime2} in iso format, supports comparison,
    sorting (converting to |str|), default \cs{Today}.
  \item[\texttt{str}]
    string，supports regex match and sorting, default empty.
  \item[\texttt{tl}]
    token list, supports regex match, default empty.
  \item[\texttt{int}]
    integer, supports comparison and sorting, default 0.
  \item[\texttt{fp}]
    floating point, supports comparison and sorting, default 0.
  \item[\texttt{clist}]
    comma list, default empty.
\end{Description}

\section{Interfaces}

\subsection{Create, Display and Clear Database}

\begin{function}{\dbNewDatabase, \dbNewDatabase*}
  \begin{syntax}
    \cs{dbNewDatabase} \oarg{base database} \marg{database} \{ \\
    ~~\meta{attr1} = \meta{type spec1}, \\
    ~~\meta{attr2} = \meta{type spec2}, \\
    ~~\ldots{} \\
    \} \\
    \cs{dbNewDatabase}* \marg{database} \{ \\
    ~~\meta{attr1} = \meta{type spec1}, \\
    ~~\meta{attr2} = \meta{type spec2}, \\
    ~~\ldots{} \\
    \} \\
  \end{syntax}

\end{function}

Create a new database named \meta{database}, unstarred form provides the optional
\meta{base database} from which current database inherit the attributes settings.
The unstarred form always replace the old definition, while starred form
appends the new options.

\begin{Syntax}
  \meta{attr} = \meta{type} \\
  \meta{attr} = \meta{type}\textbar\meta{default}
\end{Syntax}

The first form defines the \meta{attr} as \meta{type}, and the second also
sets the default value.

\begin{note}
  Every database has a default attribute |id| to store the index of the item.
\end{note}

The example below define a database named |ques|.
\begin{verbatim}
  \dbNewDatabase{ques}{
    question = tl, % store question
    answer = tl,   % store corresponding answer
    date = date,   % store the date when you were wrong
    info = tl,     % store extra info
    labels = clist % store question labels
  }
\end{verbatim}

\begin{function}{\dbshow}
  \begin{syntax}
    \cs{dbshow} \marg{style} \marg{database}
  \end{syntax}

  Show the \meta{database} with \meta{style}.
\end{function}

\begin{function}{\dbclear}
  \begin{syntax}
    \cs{dbclear} \marg{database}
  \end{syntax}

  Clear the content of \meta{database}.

\end{function}

\subsection{\cs{dbNewStyle} and Style Options}

\begin{function}{\dbNewStyle}
  \begin{syntax}
    \cs{dbNewStyle} \oarg{base styles} \marg{style} \marg{database} \marg{opts}
  \end{syntax}

Define a new \meta{style} that binds to \meta{database}. The style can inherit
from a list of \meta{base styles} such as
|\dbNewStyle[base1, base2]{new-style}{ques}{}|.
\end{function}

\bigskip

\begin{option}{opt=filter, desc={= \meta{filter}}, init=-none-}
  Set the \meta{filter} defined by \cs{dbCombineFilters}.
\end{option}

\begin{option}{opt=raw-filter, desc={= \meta{cond combination}}}
  Set anonymous with defined conditionals. Two examples below perform the same
  function.
\end{option}

\begin{verbatim}
  % method 1
  \begin{dbFilters}{db}
    \dbNewConditional{cond1}{int-attr}{\rval > 1}
    \dbNewConditional*{cond2}{str-attr}{\d+}
  \end{dbFilters}
  \dbNewStyle{style}{db}{raw-filter={cond1 && cond2}}
  % method 2
  \begin{dbFilters}{db}
    \dbNewConditional{cond1}{int-attr}{\rval > 1}
    \dbNewConditional*{cond2}{str-attr}{\d+}
    \dbCombineFilters{filter}{cond1 && cond2}
  \end{dbFilters}
  \dbNewStyle{style}{db}{filter=filter}
\end{verbatim}

\begin{option}{
  opt = sort,
  desc = {= \{ \meta{attr spec1}, \meta{attr spec2}, \ldots{} \}},
}
  Set sorting rules. Attributes of type |str, date, int, fp| is supported to
  sort.  Multi-level sort is allowed. \meta{attr} represents for ascending
  order, and \meta{attr}* represents for descending order. The example below
  use four fields to determine the order of the records. It sorts on |level|
  in descending order first and if two |levels| are same then sorts on |birth|
  in ascending order and so on.
\end{option}

\begin{verbatim}
  \dbNewDatabase{sort-example}{
    name = str,
    birth = date,
    level = int,
    weight = fp,
  }
  \dbNewStyle{sort-style}{sort-example}{
    sort = { level*, birth, name, weight }
  }
\end{verbatim}

\begin{option}{
  opt = before-code,
  desc = {= \meta{before code}}
}
  Set the \meta{before code} that is executed before displaying the database.
\end{option}

\begin{option}{
  opt = after-code,
  desc = {= \meta{after code}}
}
  Set the \meta{after code} that is executed after displaying the database.
\end{option}

\begin{option}{
  opt = item-code,
  desc = {= \meta{item code}}
}
  Set the code that show a single record. You can use \cs{dbuse} to display
  certian attribute.
\end{option}

\begin{option}{
  opt = {\meta{attr}/before-code},
  desc = {= \meta{before code}}
}
  Set the \meta{before code} that is executed by \cs{dbuse} before displaying
  certain attribute.
\end{option}

\begin{option}{
  opt = {\meta{attr}/after-code},
  desc = {= \meta{after code}}
}
  Set the \meta{after code} that is executed by \cs{dbuse} after displaying
  certain attribute.
\end{option}

\begin{option}{
  opt = {\meta{attr}/sep},
  desc = {= \meta{sep spec}},
  init = {,~\~}
}
\begin{Syntax}
  \meta{attr}/separator = \meta{separator} \\
  \meta{attr}/separator = \{ \\
  ~~\meta{separator between two}, \\
  ~~\meta{separator between more than two}, \\
  ~~\meta{separator between final two} \\
  \}
\end{Syntax}

  Only for attributes of type |clist|. Set the separator between clist items.
  The first form accept one arguments and set the seperator as \meta{sep}. The
  second form is more complicated, the following documentation is quoted from
  \pkg{interface3}:
  \begin{quote}
    If the comma list has more than two items, the \meta{separator between
    more than two} is placed between each pair of items except the last, for
    which the \meta{separator between final two} is used. If the comma list
    has exactly two items, then they are placed in the input stream separated
    by the \meta{separator between two}. If the comma list has a single item,
    it is placed in the input stream, and a comma list with no items produces
    no output.
  \end{quote}

\end{option}

\begin{option}{
  opt = item-before-code,
  desc = {= \meta{before code}}
}
  Only for attributes of type |clist|. Set the \meta{after code} that is
  excuted before displaying the item of the comma list.
\end{option}

\begin{option}{
  opt = item-after-code,
  desc = {= \meta{after code}}
}
  Only for attributes of type |clist|. Set the \meta{after code} that is
  excuted after displaying the item of the comma list.
\end{option}

\subsection{Use \cs{dbNewReviewPoints} to Define Review Points}

\begin{function}{\dbNewReviewPoints}
  \begin{syntax}
    \cs{dbNewReviewPoints} \marg{name} \marg{points}
  \end{syntax}

  Define the new \meta{points} that is specially designed for reviewing
  something. \meta{points} is a list of integers. Suppose you record the date
  when you did not answer correctly and you plan to review every 2, 5 and 15
  days. The following code give what you want.
\begin{verbatim}
  \dbNewReviewPoints{review-point}{2, 5, 15}            % define points
  \begin{dbFilters}
    \dbNewConditional{cond1}{date}{review-point|\Today} % define conditional
    \dbCombineConditionals{filter1}{cond1}              % define filter
  \end{dbFilters}
  \dbNewStyle{review-style}{ques}{filter=filter1}       % define style
\end{verbatim}
\end{function}

\subsection{Define Filters inside \env{dbFilters} Environment}

\noindent\DescribeEnv{dbFilters}
\begin{Syntax}*
  |\begin{dbFilters}|\marg{database} \\
  ~~\meta{code}
  |\end{dbFilters}| \\
\end{Syntax}

Filters are defined inside \env{dbFilters} environment, inside which,
\cs{dbNewConditional} is defined to declare conditionals and
\cs{dbCombineConditionals} is defined to combine conditionals. Filters are
independent in different databases, which means the same name of filters is
allowed in different databases.

\begin{function}{\dbNewConditional, \dbNewConditional*}
  \begin{syntax}
    \cs{dbNewConditional}  \marg{name}        \marg{attr} \marg{cond spec} \\
    \cs{dbNewConditional}* \marg{name}        \marg{attr} \marg{cond spec} \\[2pt]
    \cs{dbNewConditional}  \marg{name} \marg{int/fp attr} \marg{relation} \\
    \cs{dbNewConditional}* \marg{name} \marg{int/fp attr} \marg{relation} \\
    \cs{dbNewConditional}  \marg{name} \marg{str/tl attr} \marg{regex expr} \\
    \cs{dbNewConditional}* \marg{name} \marg{str/tl attr} \marg{regex expr} \\
    \cs{dbNewConditional}  \marg{name}  \marg{clist attr} \marg{val list} \\
    \cs{dbNewConditional}* \marg{name}  \marg{clist attr} \marg{val list} \\
    \cs{dbNewConditional}  \marg{name}   \marg{date attr} \{\meta{review points}\textbar\meta{date}\} \\
    \cs{dbNewConditional}* \marg{name}   \marg{date attr} \marg{relation}
  \end{syntax}

  Define the conditional named \meta{name} that binds to \meta{attr}. \cs{dbval}
  is replaced with the real value of the attribute inside the \meta{cond spec}.
\end{function}

For attributes of type |int| and |fp|, two forms have the same definition.
\meta{relation} can be a single relation formula, such as |\dbval > 3|, or the
combination of several relation formulas, such as |\dbval > 3 && \dbval < 10.2|.
Supported operators are |<, >, =, ==, !=, >=, <=, !|.

For attribute of type |str| and |tl|, unstarred form matches any part while
starred form matches the whole part with the \meta{regex expr}.
\begin{verbatim}
  \dbNewConditional{cond1}{str-attr}{abc}  % match abc, abcd, 1abc, =abc=, etc
  \dbNewConditional*{cond2}{str-attr}{abc} % only match abc
\end{verbatim}

For attributes of type |clist|, the conditional defined by unstarred form is
true if any item of \meta{val list} is in the comma list. While the
conditional defined by starred form is true only if every item of \meta{val
list} is in the comma list. As is showed below, for |cond1|, |a| is in
|{a, b, d}| so |cond1| is true. While |c| is not in |{a, b, d}| so |cond2| is
false.

\begin{verbatim}
  \dbNewConditional{cond1}{clist-attr}{a, b, c}  % {a, b, d} -> true
  \dbNewConditional*{cond2}{clist-attr}{a, b, c} % {a, b, d} -> false
\end{verbatim}

For attributes of type |date|, unstarred form uses \meta{review points} to
define the conditional and \meta{date} is the date to be compared. The starred
form define the conditional with \textbf{single} relation formula. Supported
operators are |<, >, =, ==, !=, >=, <=|.

\begin{function}{\dbCombineConditionals}
  \begin{syntax}
    \cs{dbCombineConditionals} \marg{name} \marg{cond combination} \oarg{info}
  \end{syntax}

  Define the filter \meta{name}, which combine the conditionals and store the
  extra \meta{info} into \cs{dbFilterInfo}. So you can write something as\\
  \verb=\dbCombineConditionals{filter}{(cond1 && cond2) || !cond3}=.\\
  Supported operators are \verb=&&, ||, !=. You can set the option \opt{filter}
  to \meta{name} to apply the filter when you display the database.
\end{function}

\subsection{Store Data with \env{dbitem} Environment}

\noindent\DescribeEnv{dbitem}
\begin{Syntax}*
  |\begin{dbitem}|\marg{database}[ \\
  ~~\meta{attr1} = \meta{val1}, \\
  ~~\meta{attr2} = \meta{val2}, \\
  ~~\ldots{} \\
  ] \\
  ~~\meta{code} \\
  |\end{dbitem}|
\end{Syntax}

The data are stored with \env{dbitem} environment in two ways. Smaller data
can be stored in the option list and the bigger data can be stored by
\cs{dbsave}, which will suppress the value set by the option list. An example
code is showned below.

\begin{verbatim}
  \begin{dbitem}[date=2022-01-01, info=test]
    \dbsave{question}{This is a test question.}
    \dbsave{answer}{This is the correct answer of the question.}
  \end{dbitem}
\end{verbatim}

\subsection{\cs{dbsave} and \cs{dbuse}}

\begin{function}{\dbsave, \dbuse}
  \begin{syntax}
    \cs{dbsave} \marg{attr} \marg{data} \\
    \cs{dbuse}  \marg{attr} \\
  \end{syntax}

  Date is stored with \cs{dbsave} and is displayed with \cs{dbuse}.  \cs{dbsave}
  can be used only inside the \env{dbitem} environment and \cs{dbuse} can be
  only used inside the option \opt{item-code}.
\end{function}

\subsection{Conditionals}

\begin{function}{\dbIfEmptyT, \dbIfEmptyF, \dbIfEmptyTF}
  \begin{syntax}
    \cs{dbIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{dbIfEmptyT} \marg{true code} \\
    \cs{dbIfEmptyF} \marg{false code}
  \end{syntax}

  Test if the database is empty. The example below shows how to avoid an empty
  list environment.
\end{function}

\begin{verbatim}
  \dbNewStyle{style-cond1}{database-test}{
    before-code = {\dbIfEmptyF{\begin{enumerate}}},
    after-code = {\dbIfEmptyF{\end{enumerate}}},
    item-code = {\item \dbuse{attr-test}}
  }
\end{verbatim}

\begin{function}{\dbItemIfEmptyT, \dbItemIfEmptyF, \dbItemIfEmptyTF}
  \begin{syntax}
    \cs{dbItemIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{dbItemIfEmptyT} \marg{true code} \\
    \cs{dbItemIfEmptyF} \marg{false code}
  \end{syntax}

  Test if the value of the attribute is empty. The example belows shows how to
  surround the non-empty |text| attribute with the symbol *.
\end{function}

\begin{verbatim}
  \dbNewStyle{style-cond2}{database-test}{
    text/before-code = {\dbItemIfEmptyF{*}},
    text/after-code = {\dbItemIfEmptyF{*}},
  }
\end{verbatim}

\begin{function}{\dbClistItemIfEmptyT, \dbClistItemIfEmptyF, \dbClistItemIfEmptyTF}
  \begin{syntax}
    \cs{dbClistItemIfEmptyTF} \marg{true code} \marg{false code} \\
    \cs{dbClistItemIfEmptyT} \marg{true code} \\
    \cs{dbClistItemIfEmptyF} \marg{false code}
  \end{syntax}

  Test if the item of comma list is empty. The example belows shows how to
  surround the non-empty label with the symbol *.
\end{function}

\begin{verbatim}
  \dbNewDatabase{database-test}{labels=clist}
  \dbNewStyle{style-cond3}{database-test}{
    labels/item-before-code = {\dbClistItemIfEmptyF{*}},
    labels/item-after-code = {\dbClistItemIfEmptyF{*}},
  }
\end{verbatim}

\subsection{Special Macros}

Some special macros are defined to expand to different contents according to context.

\DescribeMacro{\dbval} Attribute value, only accessible in \cs{dbNewConditional}.

\DescribeMacro{\dbDatabase} Database name.

\DescribeMacro{\dbFilterName} Filter name.

\DescribeMacro{\dbFilterInfo} Filter information.

\DescribeMacro{\dbIndex} Index of original records, which is equal to |\rvuse{id}| but \cs{rvuse} is nonexpandable.


\DescribeMacro{\dbarabic} Show the counter of query set as digits.

\DescribeMacro{\dbalph} Show the counter of query set as lowercase letters.

\DescribeMacro{\dbAlph} Show the counter of query set as uppercase letters.

\DescribeMacro{\dbroman} Show the counter of query set as roman numerals.

\DescribeMacro{\dbRoman} Show the counter of query set as Roman numerals.

\section{Example of Flaw Sweeper Template}
\label{sec:example}

\begin{tcblisting}{enhanced jigsaw,lower separated=false,
leftlower=0pt,rightlower=0pt,
colframe=red!50!black,colback=yellow!10!white,
listing options={style=tcblatex,texcsstyle=*\color{red!70!black}},
listing and comment,
pdf comment,freeze pdf,
compilable listing,
breakable,
run pdflatex
}
\documentclass{article}
\usepackage{amsmath, physics}
\usepackage{geometry}
\usepackage{dbshow}
\usepackage{tikz}
\usepackage{tcolorbox}
\tcbuselibrary{skins}
\usetikzlibrary{shadings}
\usepackage[hidelinks]{hyperref}

\geometry{
  margin=2cm
}

% #1 link node #2 target node #3 text to show
\NewDocumentCommand \linktarget { m m m } {%
  \hyperlink{#1}{#3}%
  \raisebox{1em}{\hypertarget{#2}{}}%
}

% question box
\tcbset{
  base/.style={
    empty,
    frame engine=path,
    colframe=yellow!10,
    coltitle=red!70,
    fonttitle=\bfseries\sffamily,
    sharp corners,
    left=4pt,
    right=4pt,
    drop fuzzy shadow,
    drop fuzzy shadow,
    borderline west={3pt}{-3pt}{red!80},
  }
}

\newtcolorbox{mybox}[1]{%
  base, title = {#1}
}

\dbNewReviewPoints{review}{1, 3, 7, 15, 30, 60}

\dbNewDatabase{ques-book}{
  ques = tl,
  answer = tl,
  count = int|1,
  labels = clist,
  date = date,
}

\begin{dbFilters}{ques-book}
  \dbNewConditional{hard}{labels}{hard}
  \dbNewConditional{bad}{count}{\dbval > 1}
  \dbNewConditional{review}{date}{review|2022-01-07}
\end{dbFilters}

% show all questions with hyperlink to answers
\dbNewStyle{ques}{ques-book}{
  before-code = {\section{Questions}},
  item-code = {
    \begin{mybox}{%
      \linktarget{answer_\dbIndex}{ques_\dbIndex}{%
        Question \dbarabic%
        \hspace{2em}\dbuse{date}%
        \hspace{2em}\dbuse{labels}%
        \hfill\dbuse{count}%
      }%
    }
      \dbuse{ques}%
    \end{mybox}
  },
  labels/sep = /,
}

% show all questions and answers with hyperlink to questions
\dbNewStyle{answer}{ques-book}{
  before-code = {\section{Questions and Answers}},
  item-code = {
    \begin{mybox}{%
      \linktarget{ques_\dbIndex}{answer_\dbIndex}{%
        Question \dbarabic%
        \hspace{2em}\dbuse{date}%
        \hspace{2em}\dbuse{labels}%
        \hfill\dbuse{count}%
      }%
    }
      \dbuse{ques}\tcbsubtitle{Answer}\dbuse{answer}%
    \end{mybox}
  },
  labels/sep = /,
}

% show all hard questions with hyperlink to answers
\dbNewStyle{hard}{ques-book}{
  before-code = {\section{Hard Questions}},
  item-code = {
    \begin{mybox}{%
      \hyperlink{answer_\dbIndex}{%
        Question \dbarabic%
        \hspace{2em}\dbuse{date}%
        \hspace{2em}\dbuse{labels}%
        \hfill\dbuse{count}%
      }%
    }
      \dbuse{ques}%
    \end{mybox}
  },
  raw-filter = hard,
  labels/sep = /,
}

% show all hard questions that have answered incorrectly for more than one
% time with hyperlink to answers
\dbNewStyle[hard]{bad}{ques-book}{
  before-code = {\section{Bad Questions}},
  raw-filter = {bad && hard},
}
% show all questions that plan to be reviewed on 2022-01-07 with hyperlink to
% answers
\dbNewStyle[hard]{review}{ques-book}{
  before-code = {\section{Questions to be Reviewed}},
  raw-filter = {review},
}

\AtEndDocument{
  \dbshow{review}{ques-book}
  \dbshow{hard}{ques-book}
  \dbshow{bad}{ques-book}
  \dbshow{ques}{ques-book}
  \dbshow{answer}{ques-book}
}

\begin{document}

\begin{dbitem}{ques-book}[
  date=2022-01-01,
  labels={math, equation, easy},
  count=2
  ]
  \dbsave{ques}{%
    Solve the linear equation: $x + 16 = 31$.
  }
  \dbsave{answer}{%
    $x = 31 - 16 = 15$
  }
\end{dbitem}

\begin{dbitem}{ques-book}[
  date=2022-01-01,
  labels={math, equation, hard},
  count=3
  ]
  \dbsave{ques}{%
    Solve the linear equation: $2y = 16$.
  }
  \dbsave{answer}{%
    $y = 16 / 2 = 8$
  }
\end{dbitem}

\begin{dbitem}{ques-book}[
  date=2022-01-04,
  labels={math, integral, hard},
  count=1
  ]
  \dbsave{ques}{%
    Find the indefinite integral: $\int 2x \dd x$.
  }
  \dbsave{answer}{%
    $\int 2x \dd x = x^2$
  }
\end{dbitem}

\end{document}
\end{tcblisting}

\section*{Change History}
\markboth{Change History}{Change History}
\addcontentsline{toc}{section}{Change History}
\noindent
\begin{tblr}{
  colspec = {lll},
  row{1} = {font=\bfseries},
}
  Date & Ver. & Describe \\
  2022-01-05 & 1.0 & {
    First version \\
    Add macro: \cmd{\dbarabic}, \cmd{\dbalph}, \cmd{\dbAlph}, \cmd{\dbroman}, \cmd{\dbRoman}
  } \\
  2022-01-06 & & {
    Fix bug: \cmd{\dbIndex} undefined \\
    Add style option: \opt{raw-filter}
  } \\
  2022-01-07 & 1.1 & {
    Improve example \\
    Add macro: \cmd{\dbclear}
  }
\end{tblr}

\end{documentation}


\end{document}
